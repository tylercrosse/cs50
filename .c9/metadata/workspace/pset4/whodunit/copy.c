{"changed":true,"filter":false,"title":"copy.c","tooltip":"/pset4/whodunit/copy.c","value":"/**\n * Copies a BMP piece by piece, just because.\n */\n       \n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"bmp.h\"\n\nint main(int argc, char *argv[])\n{\n    // ensure proper usage\n    if (argc != 3)\n    {\n        fprintf(stderr, \"Usage: ./copy infile outfile\\n\");\n        return 1;\n    }\n\n    // remember filenames\n    char *infile = argv[1];\n    char *outfile = argv[2];\n\n    // open input file \n    FILE *inptr = fopen(infile, \"r\");\n    if (inptr == NULL)\n    {\n        fprintf(stderr, \"Could not open %s.\\n\", infile);\n        return 2;\n    }\n\n    // open output file\n    FILE *outptr = fopen(outfile, \"w\");\n    if (outptr == NULL)\n    {\n        fclose(inptr);\n        fprintf(stderr, \"Could not create %s.\\n\", outfile);\n        return 3;\n    }\n\n    // read infile's BITMAPFILEHEADER\n    BITMAPFILEHEADER bf;\n    fread(&bf, sizeof(BITMAPFILEHEADER), 1, inptr);\n\n    // read infile's BITMAPINFOHEADER\n    BITMAPINFOHEADER bi;\n    fread(&bi, sizeof(BITMAPINFOHEADER), 1, inptr);\n\n    // ensure infile is (likely) a 24-bit uncompressed BMP 4.0\n    if (bf.bfType != 0x4d42 || bf.bfOffBits != 54 || bi.biSize != 40 || \n        bi.biBitCount != 24 || bi.biCompression != 0)\n    {\n        fclose(outptr);\n        fclose(inptr);\n        fprintf(stderr, \"Unsupported file format.\\n\");\n        return 4;\n    }\n\n    // write outfile's BITMAPFILEHEADER\n    fwrite(&bf, sizeof(BITMAPFILEHEADER), 1, outptr);\n\n    // write outfile's BITMAPINFOHEADER\n    fwrite(&bi, sizeof(BITMAPINFOHEADER), 1, outptr);\n\n    // determine padding for scanlines\n    int padding =  (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;\n\n    // iterate over infile's scanlines\n    for (int i = 0, biHeight = abs(bi.biHeight); i < biHeight; i++)\n    {\n        // iterate over pixels in scanline\n        for (int j = 0; j < bi.biWidth; j++)\n        {\n            // temporary storage\n            RGBTRIPLE triple;\n\n            // read RGB triple from infile\n            fread(&triple, sizeof(RGBTRIPLE), 1, inptr);\n\n            // write RGB triple to outfile\n            fwrite(&triple, sizeof(RGBTRIPLE), 1, outptr);\n        }\n\n        // skip over padding, if any\n        fseek(inptr, padding, SEEK_CUR);\n\n        // then add it back (to demonstrate how)\n        for (int k = 0; k < padding; k++)\n        {\n            fputc(0x00, outptr);\n        }\n    }\n\n    // close infile\n    fclose(inptr);\n\n    // close outfile\n    fclose(outptr);\n\n    // success\n    return 0;\n}\n","undoManager":{"mark":0,"position":-1,"stack":[[{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"insert","lines":["l"],"id":2}]]},"ace":{"folds":[],"scrolltop":1129,"scrollleft":0,"selection":{"start":{"row":63,"column":33},"end":{"row":63,"column":33},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":71,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1484437610000}